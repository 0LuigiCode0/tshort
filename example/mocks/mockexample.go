// Code generated by TShort v0.1.0 DO NOT EDIT
package mockexample

import (
	"fmt"
	"reflect"
	"testing"
	
)

type _Boo[Data any] struct {
	callers *Callers[Data]
}

type Callers[Data any] struct {
	c []iCall[Data]
}

type iCall[Data any] interface {
	getName() string
	getOut(i int) any
	check(name string, params ...any)
}

type call[Data any] struct {
	name string
	in   []any
	out  []any
}

func (c *call[Data]) getName() string {
	return c.name
}
func (c *call[Data]) check(name string, params ...any) {
	if c.name != name {
		panic(fmt.Sprintf( "%s: call was expected",c.name ))
	}
	if len(c.in) != len(params) {
		panic(fmt.Sprintf("%s: the number of parameters does not match",c.name))
	}
	for i, in := range c.in {
		if !reflect.DeepEqual(in, params[i]) {
			panic(fmt.Sprintf("%s: parameters of index %d does not match: get %v expect %v",name, i, in, params[i]))
		}
	}
}
func (c *call[Data]) getOut(i int) any {
	return c.out[i]
}

func NewBoo[Data any](t *testing.T) *_Boo[Data] {
	return &_Boo[Data]{callers: &Callers[Data]{c: make([]iCall[Data], 0, 4)}}
}
func (m *_Boo[Data]) EXPECT() *Callers[Data] {
	return m.callers
}
func (m *_Boo[Data]) Interceptor(t *testing.T) {
	m.clean()
	m.checkCallers()
}

func (m *_Boo[Data]) next() iCall[Data] {
	if len(m.callers.c) > 0 {
		c := m.callers.c[0]
		m.callers.c = m.callers.c[1:]
		return c
	}
	return nil
}
func (m *_Boo[Data]) checkCallers() {
	if len(m.callers.c) > 0 {
		var msg string
		for _, call := range m.callers.c {
			msg += call.getName() + ": call was expected\n"
		}
		panic(msg)
	}
}
func (m *_Boo[Data]) clean() {
	m.callers.c = make([]iCall[Data], 0, 4)
}

//Block A(i0 *int,i1 Data,i2 []byte) (o0 int,o1 error)----------------------

func (m *_Boo[Data]) A(i0 *int,i1 Data,i2 []byte) (o0 int,o1 error) {
	if call := m.next(); call != nil {
		call.check("A",i0,i1,i2)
		o0,_ = call.getOut(0).(int)
		o1,_ = call.getOut(1).(error)
		return
	}
	panic("A: unexpected function  is called")
}

type _A[Data any] struct {
	call[Data]
}

func (c *Callers[Data]) A(i0 *int,i1 Data,i2 []byte) *_A[Data] {
	_c := new(_A[Data])
	_c.name = "A"
	_c.in = append(_c.in, i0,i1,i2)
	c.c = append(c.c, _c)
	return _c
}

func (_c *_A[Data]) Return(o0 int,o1 error) *_A[Data] {
	_c.out = append(_c.out, o0,o1)
	return _c
}

//Block B() ()----------------------

func (m *_Boo[Data]) B() () {
	if call := m.next(); call != nil {
		call.check("B",)
		return
	}
	panic("A: unexpected function is called")
}

type _B[Data any] struct {
	call[Data]
}

func (c *Callers[Data]) B() *_B[Data] {
	_c := new(_B[Data])
	_c.name = "B"
	c.c = append(c.c, _c)
	return _c
}
