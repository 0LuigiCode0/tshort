package tgen

const tmp = `// Code generated by T-Short v0.1.0 DO NOT EDIT
package {{.Pkg}}

import (
	"fmt"
	"reflect"
	"testing"
	{{range $name,$imp := .Src.Imports.Imports}}{{if $imp.IsPrint}}
	{{$name}} "{{$imp.Path}}" {{end}}{{end}}
)

type iCall interface {
	getName() string
	getOut(i int) any
	check(name string, params ...any)
}

type call struct {
	name string
	in   []any
	out  []any
}

func (c *call) getName() string {
	return c.name
}
func (c *call) check(name string, params ...any) {
	if c.name != name {
		panic(fmt.Sprintf( "%s: call was expected",c.name ))
	}
	if len(c.in) != len(params) {
		panic(fmt.Sprintf("%s: the number of parameters does not match",c.name))
	}
	for i, in := range c.in {
		if !reflect.DeepEqual(in, params[i]) {
			panic(fmt.Sprintf("%s: parameters of index %d does not match: get %v expect %v",name, i, in, params[i]))
		}
	}
}
func (c *call) getOut(i int) any {
	return c.out[i]
}
{{range $name,$iface := .Src.Ifaces}}{{if $iface.IsPrint}}{{$genericsAll:=$iface.Generics.String}}{{$genericsShort:=$iface.Generics.StringName}}
// -------------------------------------------------------------------------- //
// MARK:{{$name}}
// -------------------------------------------------------------------------- //

type Callers{{$name}}{{$genericsAll}} struct {
	c []iCall
}


type _{{$name}}{{$genericsAll}} struct {
	callers *Callers{{$name}}{{$genericsShort}}
}

func New{{$name}}{{$genericsAll}}(t *testing.T) *_{{$name}}{{$genericsShort}} {
	return &_{{$name}}{{$genericsShort}}{callers: &Callers{{$name}}{{$genericsShort}}{c: make([]iCall, 0, 4)}}
}
func (m *_{{$name}}{{$genericsShort}}) EXPECT() *Callers{{$name}}{{$genericsShort}} {
	return m.callers
}
func (m *_{{$name}}{{$genericsShort}}) Interceptor(t *testing.T) {
	m.clean()
	m.checkCallers()
}

func (m *_{{$name}}{{$genericsShort}}) next() iCall {
	if len(m.callers.c) > 0 {
		c := m.callers.c[0]
		m.callers.c = m.callers.c[1:]
		return c
	}
	return nil
}
func (m *_{{$name}}{{$genericsShort}}) checkCallers() {
	if len(m.callers.c) > 0 {
		var msg string
		for _, call := range m.callers.c {
			msg += call.getName() + ": call was expected\n"
		}
		panic(msg)
	}
}
func (m *_{{$name}}{{$genericsShort}}) clean() {
	m.callers.c = make([]iCall, 0, 4)
}

{{range $namefunc,$func := $iface.Methods}}{{$inAll:=$func.In.String}}{{$inShort:=$func.In.Names}}{{$outAll:=$func.Out.String}}{{$outShort:=$func.Out.Names}}
// Block {{$namefunc}}({{$inAll}}) ({{$outAll}})----------------------

func (m *_{{$name}}{{$genericsShort}}) {{$namefunc}}({{$inAll}}) ({{$outAll}}) {
	if call := m.next(); call != nil {
		call.check("{{$namefunc}}",{{$inShort}}){{range $i,$v:= $func.Out}}
		{{$v.Value}},_ = call.getOut({{$i}}).({{$v.Exp}}){{end}}
		return
	}
	panic("{{$namefunc}}: unexpected function is called")
}

type _{{$namefunc}}{{$genericsAll}} struct {
	call
}

func (c *Callers{{$name}}{{$genericsShort}}) {{$namefunc}}({{$inAll}}) *_{{$namefunc}}{{$genericsShort}} {
	_c := new(_{{$namefunc}}{{$genericsShort}})
	_c.name = "{{$namefunc}}"{{if gt (len $func.In) 0}}
	_c.in = append(_c.in, {{$inShort}}){{end}}
	c.c = append(c.c, _c)
	return _c
}
{{if gt (len $func.Out) 0}}
func (_c *_{{$namefunc}}{{$genericsShort}}) Return({{$outAll}}) *_{{$namefunc}}{{$genericsShort}} {
	_c.out = append(_c.out, {{$outShort}})
	return _c
}
{{end}}{{end}}{{end}}{{end}}`
