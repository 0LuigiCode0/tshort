package tshort

const tmp = `// Code generated by T-Short v0.1.0 DO NOT EDIT
package {{.Pkg}}

import (
	"fmt"
	"reflect"
	"testing"
	{{range .Imports}}{{
	.String true
	}}{{end}}
)
{{range .Interfaces}}{{$genericsAll:=generic .Generics true}}{{$genericsShort:=generic .Generics false}}{{$nameclass:=.String false}}
type _{{$nameclass}}{{$genericsAll}} struct {
	callers *Callers{{$genericsShort}}
}

type Callers{{$genericsAll}} struct {
	c []iCall{{$genericsShort}}
}

type iCall{{$genericsAll}} interface {
	getName() string
	getOut(i int) any
	check(name string, params ...any)
}

type call{{$genericsAll}} struct {
	name string
	in   []any
	out  []any
}

func (c *call{{$genericsShort}}) getName() string {
	return c.name
}
func (c *call{{$genericsShort}}) check(name string, params ...any) {
	if c.name != name {
		panic(fmt.Sprintf( "%s: call was expected",c.name ))
	}
	if len(c.in) != len(params) {
		panic(fmt.Sprintf("%s: the number of parameters does not match",c.name))
	}
	for i, in := range c.in {
		if !reflect.DeepEqual(in, params[i]) {
			panic(fmt.Sprintf("%s: parameters of index %d does not match: get %v expect %v",name, i, in, params[i]))
		}
	}
}
func (c *call{{$genericsShort}}) getOut(i int) any {
	return c.out[i]
}

func New{{$nameclass}}{{$genericsAll}}(t *testing.T) *_{{$nameclass}}{{$genericsShort}} {
	return &_{{$nameclass}}{{$genericsShort}}{callers: &Callers{{$genericsShort}}{c: make([]iCall{{$genericsShort}}, 0, 4)}}
}
func (m *_{{$nameclass}}{{$genericsShort}}) EXPECT() *Callers{{$genericsShort}} {
	return m.callers
}
func (m *_{{$nameclass}}{{$genericsShort}}) Interceptor(t *testing.T) {
	m.clean()
	m.checkCallers()
}

func (m *_{{$nameclass}}{{$genericsShort}}) next() iCall{{$genericsShort}} {
	if len(m.callers.c) > 0 {
		c := m.callers.c[0]
		m.callers.c = m.callers.c[1:]
		return c
	}
	return nil
}
func (m *_{{$nameclass}}{{$genericsShort}}) checkCallers() {
	if len(m.callers.c) > 0 {
		var msg string
		for _, call := range m.callers.c {
			msg += call.getName() + ": call was expected\n"
		}
		panic(msg)
	}
}
func (m *_{{$nameclass}}{{$genericsShort}}) clean() {
	m.callers.c = make([]iCall{{$genericsShort}}, 0, 4)
}
{{range .Methods}}{{$namefunc:=.String false}}{{$inAll:=params .In true}}{{$inShort:=params .In false}}{{$outAll:=params .Out true}}{{$outShort:=params .Out false}}
//Block {{$namefunc}}({{$inAll}}) ({{$outAll}})----------------------

func (m *_{{$nameclass}}{{$genericsShort}}) {{$namefunc}}({{$inAll}}) ({{$outAll}}) {
	if call := m.next(); call != nil {
		call.check("{{$namefunc}}",{{$inShort}}){{range $i,$v:= .Out}}
		{{$v.String false}},_ = call.getOut({{$i}}).({{$v.Arg}}){{end}}
		return
	}
	panic("{{$namefunc}}: unexpected function is called")
}

type _{{$namefunc}}{{$genericsAll}} struct {
	call{{$genericsShort}}
}

func (c *Callers{{$genericsShort}}) {{$namefunc}}({{$inAll}}) *_{{$namefunc}}{{$genericsShort}} {
	_c := new(_{{$namefunc}}{{$genericsShort}})
	_c.name = "{{$namefunc}}"{{if gt (len .In) 0}}
	_c.in = append(_c.in, {{$inShort}}){{end}}
	c.c = append(c.c, _c)
	return _c
}
{{if gt (len .Out) 0}}
func (_c *_{{$namefunc}}{{$genericsShort}}) Return({{$outAll}}) *_{{$namefunc}}{{$genericsShort}} {
	_c.out = append(_c.out, {{$outShort}})
	return _c
}
{{end}}{{end}}{{end}}`
