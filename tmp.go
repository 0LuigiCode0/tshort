package main

const tmp = `// Code generated by TShort v0.1.0 DO NOT EDIT
package {{.Pkg}}

import (
	"fmt"
	"reflect"
	"testing"
	{{range .Imports}}{{
	.String true
	}}{{end}}
)
{{range .Interfaces}}{{$genericsAll:=generic .Generics true}}{{$genericsShort:=generic .Generics false}}{{$nameclass:=.String false}}
type Mock{{$nameclass}}{{$genericsAll}} struct {
	callers *Callers{{$genericsShort}}
}

type Callers{{$genericsAll}} struct {
	c []iCall{{$genericsShort}}
}

type iCall{{$genericsAll}} interface {
	getName() string
	checkIn(params ...any)
	getOut() []any
}

type call{{$genericsAll}} struct {
	name string
	in   []any
	out  []any
}

func (c *call{{$genericsShort}}) getName() string {
	return c.name
}
func (c *call{{$genericsShort}}) checkIn(params ...any) {
	if len(c.in) != len(params) {
		panic("the number of parameters does not match")
	}
	for i, in := range c.in {
		if !reflect.DeepEqual(in, params[i]) {
			panic(fmt.Sprintf("parameters of index %d does not match: %v != %v", i, in, params[i]))
		}
	}
}
func (c *call{{$genericsShort}}) getOut() []any {
	return c.out
}

func NewMock{{$nameclass}}{{$genericsAll}}(t *testing.T) *Mock{{$nameclass}}{{$genericsShort}} {
	return &Mock{{$nameclass}}{{$genericsShort}}{callers: &Callers{{$genericsShort}}{c: make([]iCall{{$genericsShort}}, 0, 4)}}
}
func (m *Mock{{$nameclass}}{{$genericsShort}}) EXPECT() *Callers{{$genericsShort}} {
	return m.callers
}
func (m *Mock{{$nameclass}}{{$genericsShort}}) Interceptor(t *testing.T) {
	t.Cleanup(m.clean)
	t.Cleanup(m.checkCallers)
}

func (m *Mock{{$nameclass}}{{$genericsShort}}) next() iCall{{$genericsShort}} {
	if len(m.callers.c) > 0 {
		c := m.callers.c[0]
		m.callers.c = m.callers.c[1:]
		return c
	}
	return nil
}
func (m *Mock{{$nameclass}}{{$genericsShort}}) checkCallers() {
	if len(m.callers.c) > 0 {
		var msg string
		for _, call := range m.callers.c {
			msg += call.getName() + " call was expected\n"
		}
		panic(msg)
	}
}
func (m *Mock{{$nameclass}}{{$genericsShort}}) clean() {
	m.callers.c = make([]iCall{{$genericsShort}}, 0, 4)
}
{{range .Methods}}{{$namefunc:=.String false}}{{$inAll:=params .In true}}{{$inShort:=params .In false}}{{$outAll:=params .Out true}}{{$outShort:=params .Out false}}
//Block {{$namefunc}}({{$inAll}}) ({{$outAll}})----------------------

func (m *Mock{{$nameclass}}{{$genericsShort}}) {{$namefunc}}({{$inAll}}) ({{$outAll}}) {
	if call := m.next(); call != nil {
		if call.getName() != "{{$namefunc}}" {
			panic(call.getName() + " call was expected")
		}
		call.checkIn({{$inShort}})
		{{range $i,$v:= .Out}}
		{{$v.String false}},_ = call.getOut()[{{$i}}].({{$v.Arg}}){{end}}
		return
	}
	panic("unexpected function \"A\" is called")
}

type _{{$namefunc}}{{$genericsAll}} struct {
	call{{$genericsShort}}
}

func (c *Callers{{$genericsShort}}) {{$namefunc}}({{$inAll}}) *_{{$namefunc}}{{$genericsShort}} {
	_c := new(_{{$namefunc}}{{$genericsShort}})
	_c.name = "{{$namefunc}}"{{if gt (len .In) 0}}
	_c.in = append(_c.in, {{$inShort}}){{end}}
	c.c = append(c.c, _c)
	return _c
}
{{if gt (len .Out) 0}}
func (_c *_{{$namefunc}}{{$genericsShort}}) Return({{$outAll}}) *_{{$namefunc}}{{$genericsShort}} {
	_c.out = append(_c.out, {{$outShort}})
	return _c
}
{{end}}{{end}}{{end}}`
